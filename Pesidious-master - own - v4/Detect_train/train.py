import torch
from Detect_train.utils import set_seed, set_plt_style
from Detect_train.dataset import make_loaders
from models import *
from Detect_train.utils import train, plot_confusion_matrix,get_accuracy
from Detect_models import get_detect_model
from torch import optim
import os
import torch.multiprocessing as mp
from multiprocessing import cpu_count
import configparser
import time
config = configparser.ConfigParser()

configFile = config.read('./pesidious.config')
dist = config['Detect_train_message']
model = dist['model']
batch_size =  dist['batch_size']
test_size =dist['test_size']
val_size = dist['val_size']
max_seq_len = dist['max_seq_len']
malware_dir = dist['malware_dir']
benign_dir = dist['benign_dir']
lr = dist['lr']
device = dist['device']
num_epochs = int(dist['num_epochs'])
patience = int(dist['patience'])
seed = dist['seed']


set_seed(int(seed))
set_plt_style()
if device=='cpu':
    device = "cpu"
elif device=="gpu":
    device = "cuda:0"
# device = torch.device("cpu")
# print(type(device))


batch_size = int(batch_size)
test_size =float(test_size)
val_size = float(val_size)
max_seq_len=int(max_seq_len)

# exit()
train_loader, val_loader, test_loader = make_loaders(batch_size, val_size, test_size, malware_dir ,benign_dir,max_seq_len)

model=get_detect_model(model,max_seq_len,device)

# if model == "MalConvPlus":
#     model = MalConvPlus(8, max_seq_len, 128, 32).to(device)
# elif model == "MalConvBase":
#     model = MalConvBase(8, max_seq_len, 128, 32).to(device)
# elif model == "RCNN":
#     pass
# elif model == "AttentionRCNN":
#     pass

lr=float(lr)
optimizer = optim.Adam(model.parameters(), lr=lr)

def train_start():
    #print(train_loader, val_loader, test_loader)
    today = time.strftime("%Y-%m-%d", time.localtime()) + "_"
    train(model, train_loader, val_loader,test_loader, device, today+"malconv_plus_"+str(max_seq_len)+"_",l_epoch=0,
    lr=lr,
    patience=patience,
    num_epochs=num_epochs,
    verbose=True,
    optimizer="null")

    print("-------  train over ---------")
    # plot_confusion_matrix(model, test_loader, "malconv_plus", device)
    # print('over')




def train_last(old_model_name):
    try:
        checkpoint = torch.load('./Detect_checkpoints/' + old_model_name, map_location=lambda storage, loc: storage)
    except:
        checkpoint = torch.load('./Detect_checkpoints/' + old_model_name)
    # checkpoint = torch.load('./Detect_checkpoints/'+old_model_name)

    model.load_state_dict(checkpoint['model'])
    optimizer.load_state_dict(checkpoint['optimizer'])
    l_epoch = checkpoint['epoch']
    today = time.strftime("%Y-%m-%d", time.localtime()) + "_"
    train(model, train_loader, val_loader, test_loader,device, today+"malconv_plus_"+str(max_seq_len)+"_",optimizer=optimizer,l_epoch=l_epoch,lr=lr,
    patience=patience,
    num_epochs=num_epochs,
    verbose=True,)

    print("-------  train over ---------")
    # train(model, train_loader, val_loader, device, "malconv_plus")

def read_into_buffer(filename):
    buf = bytearray(os.path.getsize(filename))
    with open(filename, 'rb') as f:

        f.readinto(buf)
    f.close()
    buf=list(buf)
    if len(buf) > max_seq_len:
        buf = buf[0:max_seq_len]
    else:
        for i in range(len(buf), max_seq_len):
            buf.append(256)
    return buf


def get_test_acc(choice_model_name):
    try:
        checkpoint = torch.load('./Detect_checkpoints/'+choice_model_name, map_location=lambda storage, loc: storage)
    except:
        checkpoint = torch.load('./Detect_checkpoints/'+choice_model_name)

    model.load_state_dict(checkpoint['model'])

    # print(get_accuracy(model, test_loader, 'cpu'))

    print("Result:"+str(get_accuracy(model, test_loader, device)))



def predict(choice_model_name,file_name):
    try:
        checkpoint = torch.load('./Detect_checkpoints/'+choice_model_name, map_location=lambda storage, loc: storage)
    except:
        checkpoint = torch.load('./Detect_checkpoints/'+choice_model_name)
    model.load_state_dict(checkpoint['model'])

    inputs = torch.tensor(read_into_buffer(file_name)).reshape(1, -1)
    # inputs = torch.tensor(read_into_buffer('./Data/malware/'+file_name)).reshape(1,-1)


    # print(inputs)
    # print(len(inputs[0]))
    outputs = model(inputs)

    # print(outputs)
    # print(torch.sigmoid(outputs))

    print("Scoreï¼š"+str(float(torch.sigmoid(outputs))))
    print('over')

# if __name__ == '__main__':
#     print("1:Train an new model")
#     print("2:Train an old model")
#     print("3:Pridict an file")
#     print("4:Get test acc")
#     print("5:Train an new model by mp cpu")
#     a=input("Please input 1 or 2 or 3 or 4 or 5:")
#
#     if a=="1":
#         train_start()
#     elif a=="2":
#         train_last()
#     elif a=="3":
#         predict()
#     elif a == "4":
#         get_test_acc()
#     elif a == "5":
#         train_mp()

