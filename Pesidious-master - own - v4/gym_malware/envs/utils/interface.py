import requests
import gzip
import json
import re
import configparser
import sys
import os
import glob

# from models import MalConvPlus,MalConvBase
from Detect_models import get_detect_model

import torch
module_path = os.path.dirname(os.path.abspath(sys.modules[__name__].__file__))


SAMPLE_PATH = os.path.join(module_path, '../../../Data/malware')
config = configparser.ConfigParser()

# for local model
from gym_malware.envs.utils.pefeatures import PEFeatureExtractor
from gym_malware.envs.utils.pefeatures2 import PEFeatureExtractor2
from sklearn.externals import joblib
feature_extractor =  PEFeatureExtractor()
feature_extractor2 =  PEFeatureExtractor2()

# for RESTful interface to remote model
from pathlib import Path
home = str(Path.home())
# home="E:\malware_rep\Pesidious-master - own"
home= os.path.join(module_path, '../../../')
config_file = str(os.path.join(home, 'pesidious.config'))
configFile = config.read(config_file)

#if config file found
#加载模型
if len(configFile) != 0:
    local_model_path = config['RL_train_massage']['saved_model']
    #load the model

    print(local_model_path)

    checkpoints_path = os.path.join(module_path, '../../../Detect_checkpoints/')
    try:
        local_model = torch.load(os.path.join(checkpoints_path, local_model_path), map_location=lambda storage, loc: storage)
    except:
        local_model = torch.load(os.path.join(checkpoints_path, local_model_path))



    # local_model = torch.load(local_model_path)

    local_model_threshold = float(config['RL_train_massage']['threshold'])/100

    remote_model_url = config['Remote-AI-model']['URL']
    remote_model_username = config['Remote-AI-model']['Username']
    remote_model_password = config['Remote-AI-model']['Password']
    remote_model_version = config['Remote-AI-model']['Version']
    remote_model_threshold = config['Remote-AI-model']['Threshold']

else:
    remote_model_url = "http://my.av.api"
    remote_model_username = "username"
    remote_model_password = "password"
    remote_model_version =  "1.0",
    remote_model_threshold =  float(config['RL_train_massage']['threshold'])/100

    local_model = joblib.load(os.path.join(module_path, 'gradient_boosting.pkl') )
    local_model_threshold = float(config['RL_train_massage']['threshold'])/100

    

class ClassificationFailure(Exception):
    pass


class FileRetrievalFailure(Exception):
    pass


#读文件
def fetch_file(sha256):
    location = os.path.join(SAMPLE_PATH, sha256)
    try:
        with open(location, 'rb') as infile:
            bytez = infile.read()
    except IOError:
        raise FileRetrievalFailure(
            "Unable to read sha256 from {}".format(location))

    return bytez


def get_available_sha256():
    sha256list = []
    for fp in glob.glob(os.path.join(SAMPLE_PATH, '*')):
        fn = os.path.split(fp)[-1]
        result = re.match(r'^[0-9a-fA-F]{64}$', fn) # require filenames to be sha256
        if result:
            sha256list.append(result.group(0))
    assert len(sha256list)>0, "no files found in {} with sha256 names".format( SAMPLE_PATH )
    return sha256list

# modify this function to git a remote API of your choice
# note that in this example, the API route expects version specification
# in addition to authentication username and password

def get_score_remote(bytez):
    try:
        response = requests.post(remote_model_url,
                                 params={'version': remote_model_version},
                                 auth=(remote_model_username,
                                       remote_model_password),
                                 headers={
                                     'Content-Type': 'application/octet-stream'},
                                 data=bytez)
    except ConnectionError:
        print("Bad route for hitting remote AV via RESTful interface. Please modify params.json (see params.json.in).")
        raise

    if not response.ok:
        raise(ClassificationFailure("Unable to get label for query"))
    json_response = response.json()
    if not 'data' in json_response or not 'score' in json_response['data']:
        raise(ClassificationFailure(
            "Can't find ['data']['score'] in response"))
    # mimic black box by thresholding here
    return json_response['data']['score']


def get_label_remote(bytez):
    # mimic black box by thresholding here
    return float( get_score_remote(bytez) >= remote_model_threshold )

configFile = config.read('../../../pesidious.config')
dist = config['RL_train_massage']

max_seq_len = int(dist['max_seq_len'])
device = dist['device']
if device == "cpu":
    device = torch.device("cpu")
elif device=="gpu":
    device = torch.device("cuda:0")


model1 = dist['model']

model=get_detect_model(model1,max_seq_len,device)

# if model1 == "MalConvPlus":
#     model = MalConvPlus(8, max_seq_len, 128, 32).to(device)
# elif model1 == "MalConvBase":
#     model = MalConvBase(8, max_seq_len, 128, 32).to(device)
# elif model1 == "RCNN":
#     pass
# elif model1 == "AttentionRCNN":
#     pass

# if len(configFile) != 0:
#     max_seq_len= config['Local-AI-model']['max_seq_len']
#     model_name = config['Local-AI-model']['model']
#     if model_name=="MalConvBase":
#         model = MalConvBase(8, max_seq_len, 128, 32).to(device)
#     elif model_name=="MalConvPlus":
#         model = MalConvPlus(8, max_seq_len, 128, 32).to(device)


model.eval()
model.load_state_dict(local_model['model'])
#获得分类器的分类结果
def get_score_local(bytez):
    # # extract features
    # features = feature_extractor2.extract( bytez )
    # # query the model
    # print("local_model")
    # print(local_model)
    # score = local_model.predict_proba( features.reshape(1,-1) )[0,-1] # predict on single sample, get the malicious score
    # inputs = torch.tensor(read_into_buffer('./Data/malware/' + 'test_malware_virus2')).reshape(1, -1)
    features = feature_extractor2.extract(bytez).reshape(1, -1).to(device)
    # print(len(features[0]))
    outputs = model(features)

    score = float(torch.sigmoid(outputs))
    return score


#获取分类器分数的接口，get_score_local的分数大于阈值就是malware，否则是benign
def get_label_local(bytez):
    # mimic black box by thresholding here
    score = get_score_local(bytez)
    label = float( get_score_local(bytez) >= local_model_threshold )
    #print("score={} (hidden), label={}".format(score,label)) 
    return label

