# TODO:
# * modify exports using lief
# * zero out rich header (if it exists) --> requires updating OptionalHeader's checksum ("Rich Header" only in Microsoft-produced executables)
# * tinker with resources: https://lief.quarkslab.com/doc/tutorials/07_pe_resource.html

import lief  # pip install https://github.com/lief-project/LIEF/releases/download/0.7.0/linux_lief-0.7.0_py3.6.tar.gz
import json
import os
import sys
import array
import struct  # byte manipulations
import random
import tempfile
import subprocess
import functools
import signal
import multiprocessing
import pickle
import pefile
import hashlib

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]



COMMON_SECTION_NAMES = pickle.load(open(os.path.join(module_path, '../../../RL_Features/adversarial_sections_set.pk'), "rb"))
COMMON_IMPORTS = pickle.load(open(os.path.join(module_path, '../../../RL_Features/adversarial_imports_set.pk'), "rb"))
section_content = "manipulation_content/section-content.txt"

class MalwareManipulator(object):
    def __init__(self, bytez):
        self.bytez = bytez
        self.min_append_log2 = 5
        self.max_append_log2 = 8

    def __random_length(self):
        return 2**random.randint(self.min_append_log2, self.max_append_log2)

    def __binary_to_bytez(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False, resources=False, tls=False):
        # write the file back as bytez
        builder = lief.PE.Builder(binary)
        builder.build_dos_stub(dos_stub) # rebuild DOS stub

        builder.build_imports(imports) # rebuild IAT in another section
        builder.patch_imports(imports) # patch original import table with trampolines to new import table

        builder.build_overlay(overlay) # rebuild overlay
        builder.build_relocations(relocations) # rebuild relocation table in another section
        builder.build_resources(resources) # rebuild resources in another section
        builder.build_tls(tls) # rebuilt TLS object in another section

        builder.build() # perform the build process

        # return bytestring
        return array.array('B', builder.get_build()).tobytes()


    #在源文件结尾加上 随机字符串的字节
    def overlay_append(self, seed=None):
        random.seed(seed)
        #获得一个随机追加长度
        L = self.__random_length()
        # choose the upper bound for a uniform distribution in [0,upper]
        #获取一个字符的上限
        upper = random.randrange(256)
        # upper chooses the upper bound on uniform distribution:
        # upper=0 would append with all 0s
        # upper=126 would append with "printable ascii"
        # upper=255 would append with any character

        # upper=0 would append with all 0s  ，只会在结尾添加L个0
        # upper=126 would append with "printable ascii" ，只会在结尾添加ascii字符
        # upper=255 would append with any character ，结尾可以添加所有字符

        #在结尾添加L个随机字符
        return self.bytez + bytes([random.randint(0, upper) for _ in range(L)])

    #添加良性的imports库
    def imports_append(self, seed=None):
        #读取良性imports库的列表名
        importsFile = open("imports.txt" , 'w')

        #随机选取一个库名
        libname = random.choice(list(COMMON_IMPORTS))


        while(len(list(COMMON_IMPORTS[libname])) < 20 ):
            libname = random.choice(list(COMMON_IMPORTS))

        importsFile.write(libname + '\n')
        for fun in (list(COMMON_IMPORTS[libname])):
            importsFile.write(fun + '\n')

        importsFile.close()

        with open("modified.exe", 'wb') as file1:
            file1.write(self.bytez)

        cmd = "portable-executable/project-add-imports/bin/Debug/project-append-import modified.exe imports.txt modified.exe"
        os.system(cmd)

        with open("modified.exe", "rb") as binfile:
            self.bytez = binfile.read()

        return self.bytez


    def section_add(self, seed=None): 
  
        section = ""
        while(len(section.strip()) < 1):   
            section = random.choice(COMMON_SECTION_NAMES)
        with open("modified.exe", 'wb') as file1:
            file1.write(self.bytez)

        cmd = "portable-executable/project-add-sections/bin/Debug/project-append-section modified.exe " + section + " " + section_content + " modified.exe"
        os.system(cmd)

        with open("modified.exe", "rb") as binfile:
            self.bytez = binfile.read()

        return self.bytez



    def section_append(self, seed=None):
        # append to a section (changes size and entropy)
        random.seed(seed)
        binary1 = lief.parse(self.bytez, name="")
        with open("modified.exe", 'wb') as file1:
            file1.write(bytez)

        binary = lief.PE.Binary("modified.exe", lief.PE.PE_TYPE.PE32)

        if(len(binary1.sections) == 0):
            self.bytez = self.__binary_to_bytez(binary)
            return self.bytez

        if(len(binary.sections) == 0):
            self.bytez = self.__binary_to_bytez(binary)
            return self.bytez


        targeted_section = random.choice(binary.sections)
        L = self.__random_length()
        available_size = targeted_section.size - len(targeted_section.content)
        if L > available_size:
            L = available_size

        upper = random.randrange(256)
        targeted_section.content = targeted_section.content + [random.randint(0, upper) for _ in range(L)]

        self.bytez = self.__binary_to_bytez(binary)
        return self.bytez

    def section_rename(self, seed=None):
        # rename a random section
        #random.seed(seed)
        print("-"*100)
        binary = lief.parse(self.bytez, name="")
        for i in range(0, 10):   
            targeted_section = random.choice(binary.sections)
            targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:7] # current version of lief not allowing 8 chars?

        self.bytez = self.__binary_to_bytez(binary)

        return self.bytez

    # 原始项目
    def create_new_entry(self, seed=None):
        # create a new section with jump to old entry point, and change entry point
        # DRAFT: this may have a few technical issues with it (not accounting for relocations), but is a proof of concept for functionality
        random.seed(seed)

        binary = lief.PE.parse(self.bytez)

        # get entry point
        entry_point = binary.optional_header.addressof_entrypoint

        # get name of section
        entryname = binary.section_from_rva(entry_point).name

        # create a new section
        new_section = lief.PE.Section(entryname + "".join(chr(random.randrange(
            ord('.'), ord('z'))) for _ in range(3)))  # e.g., ".text" + 3 random characters
        # push [old_entry_point]; ret
        new_section.content = [
            0x68] + list(struct.pack("<I", entry_point + 0x10000)) + [0xc3]
        new_section.virtual_address = max(
            [s.virtual_address + s.size for s in binary.sections])
        # TO DO: account for base relocation (this is just a proof of concepts)

        # add new section
        binary.add_section(new_section, lief.PE.SECTION_TYPES.TEXT)

        # redirect entry point
        binary.optional_header.addressof_entrypoint = new_section.virtual_address

        self.bytez = self.__binary_to_bytez(binary)
        return self.bytez

    def upx_pack(self, seed=None):
        # tested with UPX 3.91
        random.seed(seed)
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        # dump bytez to a temporary file
        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        options = ['--force', '--overlay=copy']
        compression_level = random.randint(1, 9)
        options += ['-{}'.format(compression_level)]
        # --exact
        # compression levels -1 to -9
        # --overlay=copy [default]

        # optional things:
        # --compress-exports=0/1
        # --compress-icons=0/1/2/3
        # --compress-resources=0/1
        # --strip-relocs=0/1
        options += ['--compress-exports={}'.format(random.randint(0, 1))]
        options += ['--compress-icons={}'.format(random.randint(0, 3))]
        options += ['--compress-resources={}'.format(random.randint(0, 1))]
        options += ['--strip-relocs={}'.format(random.randint(0, 1))]

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ['upx'] + options + [tmpfilename, '-o', tmpfilename + '_packed'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # successfully packed

            with open(tmpfilename + '_packed', 'rb') as infile:
                self.bytez = infile.read()

            os.unlink(tmpfilename + '_packed')

        return self.bytez

    def upx_unpack(self, seed=None):
        # dump bytez to a temporary file
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ['upx', tmpfilename, '-d', '-o', tmpfilename + '_unpacked'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # sucessfully unpacked
            with open(tmpfilename + '_unpacked', 'rb') as result:
                self.bytez = result.read()

            os.unlink(tmpfilename + '_unpacked')

        return self.bytez

    def remove_signature(self, seed=None):
        binary = lief.parse(self.bytez, name="")

        if binary.has_signature:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__binary_to_bytez(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    #原始项目
    def remove_debug(self, seed=None):
        random.seed(seed)
        binary = lief.PE.parse(self.bytez)

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__binary_to_bytez(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    # 原始项目
    def break_optional_header_checksum(self, seed=None):
        binary = lief.PE.parse(self.bytez)
        binary.optional_header.checksum = 0
        self.bytez = self.__binary_to_bytez(binary)
        return self.bytez

    def add_signature(self, seed=None):
        #http://manpages.ubuntu.com/manpages/bionic/man1/signcode.1.html
        #sign the PE file using your certificate
        return self.bytez

        

##############################
def identity(bytez, seed=None):
    return bytez


######################
# explicitly list so that these may be used externally

# ACTION_TABLE = {
#     # 'do_nothing': identity,
#     'overlay_append': 'overlay_append',
#     'imports_append': 'imports_append',
#     'section_rename': 'section_rename', #1
#     'section_add': 'section_add',
#     'section_append': 'section_append',
#     'create_new_entry': 'create_new_entry',
#     'remove_signature': 'remove_signature',
#     # 'remove_debug': 'remove_debug', #4
#     # 'upx_pack': 'upx_pack',          #2
#     # 'upx_unpack': 'upx_unpack',      #3
#     'break_optional_header_checksum': 'break_optional_header_checksum',#5
#
#     #• Modify optional header: A random value for a random optional header is chosen and added to the optional header list of the PE sample.
#     #• Add bytes to section cave：: If any byte caves exist in the PE sample, fill the cave with a random byte value.
#     #• Modify machine type：The machine type of the PE sample is changed to a random machine type.
#     #• Modify timestamp：The time date stamp in the PE header is changed to a value from a random selection.
#     #• Pad overlay：: A random byte value is appended at the end of the malware sample 100,000 times.
#     #• Append benign data overlay: The .text section of a randomly chosen benign PE file is appended at the end of the PE sample
#     #• Append benign binary overlay: A random benign PE file is read as bytes and appended at the end of the PE sample.
#     #• Add section benign data: An unused section is created in our PE sample and the contents of a random benign files .text is added to the new section.
#     #• Add section strings: A string is selected from a random set of benign strings and set as the section content of a newly generated section in our PE sample.
#     #• Add string overlay: A string is randomly selected from a set of benign strings and appended at the end of the PE sample.
#     #• Add imports: A random library is chosen from a set of libraries commonly used by benign files and added to the PE sample if it does not already exist.
#
#     #   'modify_exports' : modify_exports,
# }

from pathlib import Path
import configparser
config = configparser.ConfigParser()
home = str(Path.home())
# home="E:\malware_rep\Pesidious-master - own"
home= os.path.join(module_path, '../../../')
config_file = str(os.path.join(home, 'pesidious.config'))
configFile = config.read(config_file)
dist=config['RL_choice_action']

ACTION_TABLE = {}
for i in dist:
    ACTION_TABLE[dist[i]]=dist[i]

# print(ACTION_TABLE)
# exit()
# ACTION_TABLE = {
#     # 'do_nothing': identity,
#     # 'overlay_append': 'overlay_append',
#     'section_rename' : 'section_rename',
#     'section_add' : 'section_add',
#     'imports_append' : 'imports_append'

}


# ACTION_TABLE = {
#     # 'do_nothing': identity,
#     'overlay_append': 'overlay_append',
#     'section_rename' : 'section_rename',
#     'add_signature' : 'add_signature',
#     'section_add' : 'section_add',
#     'imports_append' : 'imports_append',
#     'remove_signature': 'remove_signature'

# }


def calculate_hash(bytez):
    m = hashlib.sha256()
    m.update( bytez )
    #print("new hash: {}".format(m.hexdigest()))

import os, sys

class HiddenPrints:
    def __enter__(self):
        self._original_stdout = sys.stdout
        sys.stdout = open(os.devnull, 'w')

    def __exit__(self, exc_type, exc_val, exc_tb):
        sys.stdout.close()
        sys.stdout = self._original_stdout

def modify_without_breaking(bytez, actions=[], seed=None):
    for action in actions:

        _action = ACTION_TABLE[action]

        # we run manipulation in a child process to shelter
        # our malware model from rare parsing errors in LIEF that
        # may segfault or timeout

        def helper(_action,shared_list):
            # TODO: LIEF is chatty. redirect stdout and stderr to /dev/null

            # for this process, change segfault of the child process
            # to a RuntimeEror
            def sig_handler(signum, frame):
                raise RuntimeError
            signal.signal(signal.SIGSEGV, sig_handler)

            bytez = array.array('B', shared_list[:]).tobytes()
            # TODO: LIEF is chatty. redirect output to /dev/null
            if type(_action) is str:
                _action = MalwareManipulator(bytez).__getattribute__(_action)
            else:
                _action = functools.partial( _action, bytez )

            # redirect standard out only in this queue
            try:
                shared_list[:] = _action(seed) 
            except (RuntimeError,UnicodeDecodeError,TypeError,lief.not_found) as e:
                # some exceptions that have yet to be handled by public release of LIEF
                print("==== exception in child process ===")
                print(e)
                # shared_bytez remains unchanged                


        # communicate with the subprocess through a shared list
        # can't use multiprocessing.Array since the subprocess may need to
        # change the size
        manager = multiprocessing.Manager()
        shared_list = manager.list() 
        shared_list[:] = bytez # copy bytez to shared array

        # define process

        p = multiprocessing.Process(target=helper, args=(_action, shared_list))
        # p = multiprocessing.Process( target=helper, args=(_action,shared_list) )

        # exit()
        #规避print输出
        with HiddenPrints():
            p.start() # start the process
        # exit()
        try:
            p.join(5) # allow this to take up to 5 seconds...
        except multiprocessing.TimeoutError: # ..then become petulant
            print('==== timeouterror ')
            p.terminate()

        bytez = array.array('B', shared_list[:]).tobytes() # copy result from child process

    import hashlib
    m = hashlib.sha256()
    m.update( bytez )

    #print("new hash: {}".format(m.hexdigest()))
    return bytez
